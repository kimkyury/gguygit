---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';

type TimelinePost = {
  id: string;
  slug: string;
  title: string;
  date: Date;
  dateKey: string;
  categoryKey: 'thoughts' | 'echoes';
  categoryLabel: string;
  href: string;
  summary?: string;
};

type TimelineGroup = {
  key: string;
  dateKey: string;
  displayDate: string;
  items: TimelinePost[];
  categories: Array<'thoughts' | 'echoes'>;
};

type SnakeNode = {
  row: number;
  col: number;
  x: number;
  y: number;
  markerX: number;
  group: TimelineGroup;
  stack: number;
  primary: 'thoughts' | 'echoes';
  isMixed: boolean;
  single: TimelinePost | null;
  tooltip: string;
};
type Point = { x: number; y: number };

const toDateKey = (date: Date) => date.toISOString().slice(0, 10);
const toDisplayDate = (dateKey: string) => dateKey.replace(/-/g, '.');

const thoughtsEntries = await getCollection('thoughts');
const echoesEntries = await getCollection('echoes');

const posts: TimelinePost[] = [
  ...thoughtsEntries.map((entry) => ({
    id: `thoughts:${entry.slug}`,
    slug: entry.slug,
    title: entry.data.title,
    date: entry.data.date,
    dateKey: toDateKey(entry.data.date),
    categoryKey: 'thoughts' as const,
    categoryLabel: '단상',
    href: `/thoughts/${entry.slug}`,
    summary: entry.data.summary
  })),
  ...echoesEntries.map((entry) => ({
    id: `echoes:${entry.slug}`,
    slug: entry.slug,
    title: entry.data.title,
    date: entry.data.date,
    dateKey: toDateKey(entry.data.date),
    categoryKey: 'echoes' as const,
    categoryLabel: '여운',
    href: `/echoes/${entry.slug}`,
    summary: entry.data.summary
  }))
].sort((a, b) => b.date.valueOf() - a.date.valueOf());

const grouped = new Map<string, TimelineGroup>();

for (const post of posts) {
  const existing = grouped.get(post.dateKey);
  if (!existing) {
    grouped.set(post.dateKey, {
      key: post.dateKey,
      dateKey: post.dateKey,
      displayDate: toDisplayDate(post.dateKey),
      items: [post],
      categories: [post.categoryKey]
    });
    continue;
  }

  existing.items.push(post);
  if (!existing.categories.includes(post.categoryKey)) {
    existing.categories.push(post.categoryKey);
  }
}

const groups = Array.from(grouped.values());
const markerCount = groups.length;
const recentPosts = posts.slice(0, 3);

const columns = 4;
const totalRows = Math.max(1, Math.ceil(markerCount / columns));

const colWidth = 165;
const rowHeight = 150;
const padX = 16;
const padY = 26;

const canvasWidth = padX * 2 + columns * colWidth;
const canvasHeight = padY * 2 + totalRows * rowHeight;

const nodes: SnakeNode[] = groups.map((group, index) => {
  const row = Math.floor(index / columns);
  const inRow = index % columns;
  const reverse = row % 2 === 1;
  const col = reverse ? columns - 1 - inRow : inRow;

  const x = padX + col * colWidth + colWidth / 2;
  const y = padY + row * rowHeight + rowHeight * 0.42;
  const edgeInset = 24;
  const markerX = col === 0 ? x + edgeInset : col === columns - 1 ? x - edgeInset : x;

  const stack = group.items.length;
  const isMixed = group.categories.length > 1;
  const primary = group.categories[0];
  const single = stack === 1 ? group.items[0] : null;
  const tooltip = single
    ? `${single.title} · ${single.categoryLabel} · ${group.displayDate}`
    : `${group.displayDate} · ${stack}개 포스트`;

  return {
    row,
    col,
    x,
    y,
    markerX,
    group,
    stack,
    primary,
    isMixed,
    single,
    tooltip
  };
});

const points: Point[] = nodes.map((node) => ({ x: node.x, y: node.y }));

const unit = (dx: number, dy: number) => {
  const len = Math.hypot(dx, dy);
  if (len === 0) return { x: 0, y: 0 };
  return { x: dx / len, y: dy / len };
};

const buildRoundedPath = (pts: Point[], radius = 20) => {
  if (pts.length === 0) return '';
  if (pts.length === 1) return `M ${pts[0].x} ${pts[0].y}`;
  if (pts.length === 2) return `M ${pts[0].x} ${pts[0].y} L ${pts[1].x} ${pts[1].y}`;

  let d = `M ${pts[0].x} ${pts[0].y}`;

  for (let i = 1; i < pts.length - 1; i += 1) {
    const a = pts[i - 1];
    const b = pts[i];
    const c = pts[i + 1];

    const inVec = unit(b.x - a.x, b.y - a.y);
    const outVec = unit(c.x - b.x, c.y - b.y);

    const distIn = Math.hypot(b.x - a.x, b.y - a.y);
    const distOut = Math.hypot(c.x - b.x, c.y - b.y);
    const r = Math.min(radius, distIn / 2, distOut / 2);

    const p1 = { x: b.x - inVec.x * r, y: b.y - inVec.y * r };
    const p2 = { x: b.x + outVec.x * r, y: b.y + outVec.y * r };

    d += ` L ${p1.x} ${p1.y} Q ${b.x} ${b.y} ${p2.x} ${p2.y}`;
  }

  const end = pts[pts.length - 1];
  d += ` L ${end.x} ${end.y}`;
  return d;
};

const extendEndpoints = (
  pts: Point[],
  extra = 22,
  lastRowIsSingle = false,
  lastRowReverse = false
) => {
  if (pts.length < 2) return pts;

  const first = pts[0];
  const second = pts[1];
  const last = pts[pts.length - 1];
  const prev = pts[pts.length - 2];

  const startDir = unit(first.x - second.x, first.y - second.y);
  const endDir = lastRowIsSingle
    ? { x: lastRowReverse ? -1 : 1, y: 0 }
    : unit(last.x - prev.x, last.y - prev.y);

  const start = { x: first.x + startDir.x * extra, y: first.y + startDir.y * extra };
  const end = { x: last.x + endDir.x * extra, y: last.y + endDir.y * extra };

  return [start, ...pts, end];
};

const lastUsedRow = nodes.length > 0 ? nodes[nodes.length - 1].row : 0;
const lastRowCount = nodes.filter((node) => node.row === lastUsedRow).length;
const lastRowReverse = lastUsedRow % 2 === 1;
const lastRowIsSingle = lastRowCount === 1;

const snakePath = buildRoundedPath(
  extendEndpoints(points, 22, lastRowIsSingle, lastRowReverse),
  20
);
---

<BaseLayout
  title="Home"
  description="GGUGIT 홈: thoughts와 echoes를 중심으로 날짜별 기록을 탐색하는 타임라인입니다."
>
  <section class="timeline-home">
    <header class="hero">
      <h1>하루가 똑같던 날이 없었다</h1>
      <p class="hero-meta"> 쓴 날, 총 {markerCount}일</p>
    </header>

    {markerCount === 0 ? (
      <p class="empty">아직 표시할 타임라인 데이터가 없습니다.</p>
    ) : (
      <div class="timeline-body">
        <div class="snake-shell" aria-label="세로 스네이크 타임라인">
          <div class="snake-canvas" style={{ '--canvas-w': `${canvasWidth}px`, '--canvas-h': `${canvasHeight}px` }}>
            <svg
              class="snake-path"
              viewBox={`0 0 ${canvasWidth} ${canvasHeight}`}
              aria-hidden="true"
              focusable="false"
            >
              <path d={snakePath}></path>
            </svg>

            {nodes.map((node) => (
              <div class="snake-node" role="listitem" style={{ '--x': `${node.markerX}px`, '--y': `${node.y}px` }}>
                <a
                  href={node.single ? node.single.href : node.group.items[0].href}
                  class:list={{
                    marker: true,
                    thoughts: node.primary === 'thoughts' && !node.isMixed,
                    echoes: node.primary === 'echoes' && !node.isMixed,
                    mixed: node.isMixed
                  }}
                  style={{ '--stack': node.stack }}
                  data-tooltip={node.tooltip}
                  aria-label={node.tooltip}
                >
                  {node.stack > 1 && <span class="count" aria-hidden="true">{node.stack}</span>}
                </a>
                <span class="date-label marker-label">{node.group.displayDate}</span>
              </div>
            ))}
          </div>
        </div>

        {recentPosts.length > 0 && (
          <section class="recent" aria-label="최근 글">
            <h2>가까운 하루</h2>
            <ul>
              {recentPosts.map((post) => (
                <li>
                  <a href={post.href}>
                    <span class="title">{post.title}</span>
                    <span class="meta">{post.dateKey.replace(/-/g, '.')} · {post.categoryLabel}</span>
                  </a>
                </li>
              ))}
            </ul>
          </section>
        )}
      </div>
    )}

  </section>

  <script>
    const nodes = document.querySelectorAll<HTMLElement>('.snake-node');
    nodes.forEach((node) => {
      const marker = node.querySelector<HTMLAnchorElement>('.marker');
      if (!marker) return;
      marker.addEventListener('click', () => {
        nodes.forEach((other) => other.classList.remove('active'));
        node.classList.add('active');
      });
    });
  </script>
</BaseLayout>

<style>
  .timeline-home {
    display: grid;
    gap: 26px;
    position: relative;
  }

  .hero {
    display: grid;
    gap: 12px;
    margin-top: 8px;
  }

  .hero h1 {
    margin: 0;
    font-family: 'JN_leanring', var(--font-display);
    font-weight: 300;
    font-size: clamp(1.7rem, 3.6vw, 2.45rem);
    line-height: 1.16;
  }

  .hero-meta {
    margin: 0;
    color: var(--color-muted);
    font-size: 0.82rem;
    letter-spacing: 0.04em;
    opacity: 0.82;
  }

  .empty {
    margin: 0;
    color: var(--color-muted);
  }

  .snake-shell {
    overflow: hidden;
    padding: 2px 0 2px;
    margin-top: 4px;
  }

  .timeline-body {
    display: grid;
    gap: 18px;
    align-items: start;
  }

  .snake-canvas {
    position: relative;
    width: var(--canvas-w);
    height: var(--canvas-h);
    min-width: var(--canvas-w);
    margin: 0 auto;
  }

  .snake-path {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    overflow: visible;
  }

  .snake-path path {
    fill: none;
    stroke: rgba(27, 26, 23, 0.19);
    stroke-width: 1.2;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .snake-node {
    position: absolute;
    left: var(--x);
    top: var(--y);
    transform: translate(-50%, -50%);
    width: 1px;
    height: 1px;
    z-index: 2;
  }

  .marker {
    --stack: 1;
    --marker-color: #f0a500;

    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: clamp(2px, calc(1px + var(--stack) * 1px), 5px);
    height: calc(15px + (var(--stack) - 1) * 3px);
    border: none;
    border-radius: 2px;
    background: var(--marker-color);
    text-decoration: none;
    color: inherit;
    opacity: 0.92;
    transition: transform 0.18s ease, opacity 0.18s ease;
  }

  .marker.thoughts {
    --marker-color: #e45826;
  }

  .marker.echoes {
    --marker-color: #f0a500;
  }

  .marker.mixed {
    background: linear-gradient(180deg, #e45826 0%, #f0a500 100%);
  }

  .marker:hover,
  .marker:focus-visible {
    transform: translate(-50%, calc(-50% - 3px));
    opacity: 1;
    outline: none;
  }

  .marker::after {
    content: attr(data-tooltip);
    position: absolute;
    left: 50%;
    bottom: calc(100% + 10px);
    transform: translateX(-50%);
    white-space: nowrap;
    background: rgba(27, 26, 23, 0.92);
    color: #f8f4ee;
    font-size: 0.72rem;
    letter-spacing: 0.04em;
    padding: 6px 8px;
    border-radius: 8px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.14s ease;
  }

  .marker:hover::after,
  .marker:focus-visible::after {
    opacity: 1;
  }

  .count {
    position: absolute;
    top: -16px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.64rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--color-muted);
  }

  .date-label {
    position: absolute;
    left: 50%;
    top: 15px;
    transform: translateX(-50%);
    font-size: 0.64rem;
    letter-spacing: 0.09em;
    color: var(--color-muted);
    white-space: nowrap;
  }

  .marker-label {
    opacity: 0;
    transform: translateY(-4px);
    transition: opacity 0.15s ease, transform 0.15s ease;
  }

  .snake-node:hover .marker-label,
  .snake-node.active .marker-label {
    opacity: 1;
    transform: translateY(0);
  }

  .recent {
    border-top: 1px solid rgba(27, 26, 23, 0.18);
    padding-top: 14px;
    display: grid;
    gap: 8px;
    max-width: 520px;
  }

  .recent h2 {
    margin: 0;
    font-family: 'Junction', var(--font-display);
    font-size: 0.82rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--color-muted);
  }

  .recent ul {
    list-style: none;
    margin: 0;
    padding: 0;
    display: grid;
  }

  .recent li + li {
    border-top: 1px solid rgba(27, 26, 23, 0.1);
  }

  .recent a {
    display: grid;
    gap: 4px;
    text-decoration: none;
    color: inherit;
    padding: 10px 0;
  }

  .recent .title {
    font-size: 0.98rem;
  }

  .recent .meta {
    font-size: 0.76rem;
    color: var(--color-muted);
    letter-spacing: 0.05em;
  }

  @media (max-width: 720px) {
    .snake-canvas {
      margin: 0;
    }
  }

  @media (min-width: 1180px) {
    .timeline-body {
      grid-template-columns: minmax(0, 1fr) 280px;
      gap: 30px;
    }

    .recent {
      max-width: none;
      border-top: none;
      border-left: 1px solid rgba(27, 26, 23, 0.14);
      padding-top: 0;
      padding-left: 18px;
      margin-top: 10px;
    }
  }
</style>

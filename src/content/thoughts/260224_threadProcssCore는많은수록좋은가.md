---
title: "Thread, Process, Core는 많을수록 좋을까?"
date: 2026-02-24
cover: "/images/hero-main.png"
summary: "Thread, Process, Core는 많을수록 좋을까?"
tags: ["CS"]
---

# Thread, Process, Core는 많을수록 좋을까?

보통 이런 질문은 느낌상 **“아니니까 묻는 것 같은데?”** 라는 직감을 준다.

누군가 “각각이 많을수록 어떤 영향이 있나요?” 라고 물어보면, 단순히 생각했을 때:

- **Core**는 뇌 같은 역할이니 많을수록 처리량이 늘 것 같고,
- 한 프로그램 내에 **Process**가 여러 개면 병렬 처리 기회가 늘 것 같고,
- **Thread**가 여러 개면 이것도 병렬 처리에 유리할 것 같다.

이 생각이 틀렸는지 판단하기 위해 각각을 살펴보자.

---

## Thread가 많으면 어떨까?

Thread는 크게 **하드웨어 입장**과 **소프트웨어 입장**으로 볼 수 있다. 여기서는 **소프트웨어 입장(= 하나의 Process 내부 Thread들)** 로 가정한다.

Thread가 여러 개일 때, 코어를 통해 병렬 수행이 가능함을 우리는 알고 있다. 하지만 여기서 하나만 짚고 가자.

> **“병렬(Parallelism)과 동시성(Concurrency)은 다르다.”**

- **병렬**: 정말 _동시에_ 처리됨
- **동시성**: 여러 작업이 *빠르게 전환*되며 동시에 되는 것처럼 보임

진짜 병렬 처리를 하려면, CPU 코어가 **충분한 개수** 있어야 한다. 그렇지 못하면 **Context Switching 비용**이 발생한다.

### 예시: 유튜브 프로세스

유튜브 프로세스가 있다고 하자. 이 프로세스는 **영상, 댓글, 광고**를 각각 처리하는 Thread가 총 **3개(t1, t2, t3)** 있다고 가정한다.

- CPU가 **하이퍼스레딩**을 지원해서 코어당 2개의 하드웨어 스레드를 제공하고,
- 하드웨어 스레드 수가 프로세스의 스레드 수만큼 **충분히 받쳐준다면**  
  → 실제로 병렬 수행에 가까워질 수 있다.

하지만 상황이 달라져서, **Process의 Thread 수만큼 CPU 하드웨어 스레드가 제공되지 못한다면?**

- CPU는 한 코어(혹은 제한된 하드웨어 스레드)로 여러 Thread를 번갈아 처리해야 한다.
- 시분할 스케줄링에 따라 `t1 → t2 → t3 ...` 를 빠르게 전환하며  
  **마치 동시에 수행하는 것처럼** 보이게 된다.

### Thread가 지나치게 많으면 생기는 문제

이 환경에서 Process가 스레드로 지나치게 분할되어 있다면:

- Context Switching이 많이 발생하고,
- 프로세스/스레드 전환 비용은 **캐시 미스 등으로 무시할 수준이 아니며**
- 결국 **자원 낭비**가 생긴다.

따라서 “Thread가 많으면 좋을까?”는 이렇게 정리할 수 있다.

1. **CPU 자원이 받쳐주지 못하면** Context Switching 비용이 비효율적으로 증가한다.
2. Thread는 **메모리/캐시 등 자원을 공유**하므로 경쟁이 심해질 수 있고, 성능 저하나 **데드락 위험**이 커질 수 있다.

---

## Process가 많으면 어떨까?

잘 알려진 예로, 웹 브라우저는 여러 프로세스로 구성되어 있다.

Process는:

- **독립된 실행 단위**
- **독립된 메모리 공간**을 차지하는 존재다.

“프로그램 내에 Process가 여러 개면 각자 병렬로 처리될 수 있지 않을까?”  
또 “독립적이면 안전하고 확장성도 좋은 거 아닌가?” 라고 생각할 수 있다.

결론부터 말하면, **부분적으로는 맞다.** 하지만 비용이 따라온다.

### 1) Context Switching 비용

Process 간 Context Switching은 Thread보다 **더 많은 비용**이 든다.

- Thread는 같은 프로세스 내 공유 영역이 있으니 상대적으로 덜하지만,
- Process는 메모리 공간/파일 등 관리해야 할 정보가 더 많다.

### 2) 메모리 사용량 증가

Process는 독립된 메모리 공간을 가지므로:

- 중복되는 영역이 늘어나고,
- 전체 메모리 사용량이 증가한다.

메모리가 부족해지면 **Swap**(디스크로 임시 저장)이 발생할 수 있는데, 이건 비용이 매우 크다.

### 3) 프로세스 간 통신(IPC) 비용

프로세스는 독립적으로 실행되므로 데이터를 주고받으려면 보통 **IPC(Inter-Process Communication)** 를 쓴다.  
이 통신 자체도 **성능 저하 요인**이 될 수 있다.

---

## Core가 많으면 어떨까?

“그럼 PC 자체 성능이 높으면 무조건 좋은 거 아닌가?” 라는 생각을 하게 된다.

CPU는 OS에 의해 **프로세스의 스레드를 작업 단위로 실행**한다.  
OS는 여러 스레드를 하드웨어 스레드에 매핑하고, 코어 간 부하 균형을 조정해 효율을 높이려 한다.

각 코어가 메모리를 활용해 실행 속도 향상에 기여할 거라 기대하지만… 결론만 보면 이것도 조건이 있다.

### 1) 소프트웨어적 한계

멀티코어는 하드웨어만 있다고 되는 게 아니라, **소프트웨어가 멀티코어를 활용하도록 설계**되어야 한다.

- 프로그램이 멀티스레드/병렬 처리를 지원해야 의미가 있다.
- 실행 프로그램이 **단일 스레드**로 설계되어 있다면, 추가 코어는 놀 가능성이 크다.

### 2) 비용 증가

하드웨어 성능이 올라가면 결국 비용 문제가 따라온다.

- 지원이 안 되거나
- 복잡한 작업이 필요 없는 상황이라면

비싼 고급 CPU를 쓰는 것은 **효율적이지 않을 수 있다.**

---
